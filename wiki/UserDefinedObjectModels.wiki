#summary Version 2 Feature: User-Defined Data Models in JSON-C.

= [Version2 Version 2] Feature: User-Defined Data Models in JSON-C =

Reference: [http://code.google.com/apis/youtube/2.0/developers_guide_jsonc.html YouTube JSON-C Developer's Guide]

Code snippets from: [http://code.google.com/p/gdata-java-client/source/browse/tags/2.1.0-alpha/sample/youtube/youtube-jsonc-sample/src/com/google/api/data/sample/youtube/YouTubeBasicJsoncSample.java youtube-jsonc-sample]

User-defined data models in JSON-C are similar to [UserDefinedObjectModelsXml user-defined object models in XML].  The developer provides the data models in the form of Plain Old Java Objects (POJO's) with public fields, and the library takes care of parsing/serialization to JSON.

Currently only !YouTube has a JSON-C feed, and it is read-only.  The good news is that JSON is generally much easier and more natural to use than XML.

Let's take a look at a typical partial JSON-C video feed from the !YouYube Data API (showing only the data our sample application is interested in):

{{{
 "data":{
    "updated":"2010-01-07T19:58:42.949Z",
    "totalItems":800,
    "startIndex":1,
    "itemsPerPage":1,
    "items":[
        {"id":"hYB0mn5zh2c",
         "updated":"2010-01-07T13:26:50.000Z",
         "title":"Google Developers Day US - Maps API Introduction",
         "description":"Google Maps API Introduction ...",
         "tags":[
            "GDD07","GDD07US","Maps"
         ],
         "player":{
            "default":"http://www.youtube.com/watch?v\u003dhYB0mn5zh2c"
         },
...
        }
    ]
 }
}}}

How would you represent that in Java?  Here's one way to represent it for our sample application:

{{{

import com.google.api.client.DateTime;
import com.google.api.client.Name;
import java.util.List;

  public static class VideoFeed {
    public int itemsPerPage;
    public int startIndex;
    public int totalItems;
    public DateTime updated;
    public List<Video> items;
  }

  public static class Video {
    public String id;
    public String title;
    public DateTime updated;
    public String description;
    public List<String> tags;
    public Player player;
  }

  public static class Player {
    // "default" is a Java keyword, so need to specify the JSON key manually
    @Name("default")
    public String defaultUrl;
  }
}}}

Similarly, we can build URI using our own defined object model:

{{{
import com.google.api.client.http.HttpRequest;
import com.google.api.client.http.googleapis.GoogleTransport;
import com.google.api.client.http.googleapis.GoogleUriEntity;
import com.google.api.data.youtube.v2.YouTubePath;
import java.io.IOException;

  public static class YouTubeUri extends GoogleUriEntity {

    public String author;

    @Name("max-results")
    public Integer maxResults;

    public YouTubeUri(String uri) {
      super(uri);
      this.alt = "jsonc";
    }
  }

  private static VideoFeed showVideos(GoogleTransport transport) throws IOException {
    YouTubePath path = YouTubePath.videos();
    YouTubeUri uri = new YouTubeUri(path.build());
    uri.author = "searchstories";
    String videosUri = uri.build();
}}}

Now we execute the request and parse the result:

{{{
    HttpRequest request = transport.buildGetRequest(videosUri);
    VideoFeed feed = request.execute().parseAs(VideoFeed.class);
    System.out.println("Total number of videos: " + feed.totalItems);
    for (Video video : feed.items) {
      showVideo(video);
    }
  }
}}}

We use memory more efficiently because we only store the data we need, and drop the data we don't need.

Now, how do we handle a normal error response from the server?  The execute() method will throw an !HttpResponseException (which extends IOException) and has an !HttpResponse response field.  If the error response is a structured JSON error response, you can use the same user-defined data model technique for parsing the error response:

{{{
import com.google.api.client.Entity;
import com.google.api.client.http.HttpResponseException;

    try {
...
    } catch (HttpResponseException e) {
      if (e.response.getParser() != null) {
        System.err.println(e.response.parseAs(Entity.class));
      } else {
        System.err.println(e.response.parseAsString());
      }
      throw e;
    }
}}}

Note that here we were lazy and used Entity which is a generic entity that processes all fields.  Your application may want to do something more specific.

NOTE: As you might guess, the library uses reflection to populate the user-defined data model.  It's not quite as fast as writing the wire format parsing code yourself can potentially be, but it's a lot easier.

NOTE: If you prefer to use your favorite JSON parsing library instead (there are many of them listed for example on http://json.org), that's supported as well.  Just call request.execute() and parse the returned byte stream.