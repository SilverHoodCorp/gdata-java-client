#summary Version 2 Feature: User-Defined Data Models in XML.

= [Version2 Version 2] Feature: User-Defined Data Models in XML =

Reference: [http://code.google.com/apis/picasaweb/docs/2.0/developers_guide_protocol.html Picasa Web Albums Atom XML Developer's Guide]

Code snippets from: [http://code.google.com/p/gdata-java-client/source/browse/tags/2.1.0-alpha/sample/picasa/picasa-atom-sample/src/com/google/api/data/sample/picasa/PicasaBasicAtomSample.java picasa-atom-sample]

User-defined data models in XML are similar to [UserDefinedObjectModels user-defined data models in JSON].  The developer provides the data models in the form of Plain Old Java Objects (POJO's) with public fields, and the library takes care of parsing/serialization to XML.

All Google Data API's have an XML feed based on the open standard Atom Publishing Protocol.  However, Atom feeds are not as elegant or easy to use as JSON, because we have to manage XML namespaces.

Let's take a look at a typical Atom XML album feed from the Picasa Web Albums Data API (showing only the data our sample application is interested in):

{{{
<?xml version='1.0' encoding='utf-8'?>
<feed xmlns='http://www.w3.org/2005/Atom'
    xmlns:openSearch='http://a9.com/-/spec/opensearch/1.1/'
    xmlns:gphoto='http://schemas.google.com/photos/2007'>
  <link rel='http://schemas.google.com/g/2005#post'
    type='application/atom+xml'
    href='http://picasaweb.google.com/data/feed/api/user/liz' />
  <author>
    <name>Liz</name>
  </author>
  <openSearch:totalResults>1</openSearch:totalResults>
  <entry gd:etag='"RXY8fjVSLyp7ImA9WxVVGE8KQAE."'>
    <category scheme='http://schemas.google.com/g/2005#kind'
      term='http://schemas.google.com/photos/2007#album' />
    <title>lolcats</title>
    <summary>Hilarious Felines</summary>
    <gphoto:access>public</gphoto:access>
  </entry>
</feed>
}}}

How would you represent that in Java?  Here's one way to represent it for our sample application:

{{{
import com.google.api.client.Name;
import java.util.List;

  public static class Link {

    @Name("@href")
    public String href;

    @Name("@rel")
    public String rel;
  }

  public static String getLink(List<Link> links, String rel) {
    for (Link link : links) {
      if (rel.equals(link.rel)) {
        return link.href;
      }
    }
    return null;
  }

  public static class Category {

    @Name("@scheme")
    public String scheme;

    @Name("@term")
    public String term;
  }

  public static Category newKind(String kind) {
    Category category = new Category();
    category.scheme = "http://schemas.google.com/g/2005#kind";
    category.term = "http://schemas.google.com/photos/2007#" + kind;
    return category;
  }

  public static class AlbumEntry {

    public String summary;

    public String title;

    @Name("gphoto:access")
    public String access;

    public Category category = newKind("album");
  }

  public static class Author {
    public String name;
  }

  public static class AlbumFeed {

    public Author author;

    @Name("openSearch:totalResults")
    public int totalResults;

    @Name("entry")
    public List<AlbumEntry> entries;

    @Name("link")
    public List<Link> links;

    String getPostLink() {
      return getLink(links, "http://schemas.google.com/g/2005#post");
    }
  }
}}}


Similarly, we can build URI using our own defined data model:

{{{
import com.google.api.client.http.HttpRequest;
import com.google.api.client.http.UriEntity;
import com.google.api.client.http.googleapis.GoogleTransport;
import com.google.api.data.picasa.v2.PicasaPath;
import java.io.IOException;

  public static class PicasaUri extends UriEntity {

    @Name("max-results")
    public Integer maxResults;

    public String kinds;

    public PicasaUri(String uri) {
      super(uri);
    }
  }

  private static AlbumFeed showAlbums(GoogleTransport transport) throws IOException {
    // build URI for the default user feed of albums
    PicasaPath path = PicasaPath.feed();
    path.user = "default";
    PicasaUri uri = new PicasaUri(path.build());
    uri.kinds = "album";
    String albumsUri = uri.build();
}}}

Now we execute the request and parse the result:

{{{
    HttpRequest request = transport.buildGetRequest(albumsUri);
    AlbumFeed feed = request.execute().parseAs(AlbumFeed.class);
    System.out.println("User: " + feed.author.name);
    System.out.println("Total number of albums: " + feed.totalResults);
    for (AlbumEntry album : feed.entries) {
      showAlbum(transport, album);
    }
  }
}}}

We use memory more efficiently because we only store the data we need, and drop the data we don't need.

Now, let's POST a new album to the album feed:

{{{
import com.google.api.data.picasa.v2.atom.PicasaAtom;

  private static AlbumEntry postAlbum(GoogleTransport transport, AlbumFeed feed) throws IOException {
    AlbumEntry newAlbum = new AlbumEntry();
    newAlbum.access = "private";
    newAlbum.title = "A new album";
    newAlbum.summary = "My favorite photos";
    HttpRequest request = transport.buildPostRequest(feed.getPostLink());
    request.setContent(new AtomSerializer(PicasaAtom.NAMESPACE_DICTIONARY, newAlbum));
    AlbumEntry album = request.execute().parseAs(AlbumEntry.class);
    showAlbum(transport, postedAlbum);
    return postedAlbum;
  }
}}}

Now, let's use PATCH to update just the title of the album:

{{{
import com.google.api.client.Entities;

  private static AlbumEntry updateTitle(GoogleTransport transport, AlbumEntry album) throws IOException {
    AlbumEntry patched = Entities.clone(album);
    patched.title = "My favorite web logos";
    HttpRequest request = transport.buildPatchRequest(album.getEditLink());
    request.setIfMatchHeader(album.etag);
    request.setContent(new PatchRelativeToOriginalSerializer(PicasaAtom.NAMESPACE_DICTIONARY, patched, album));
    album = request.execute().parseAs(AlbumEntry.class);
    showAlbum(transport, album);
    return album;
  }
}}}

Only the title gets sent over the network because that is the only field changed.

In the past before PATCH was implemented, you had to use PUT to update the whole entry.  Not only was it less efficient over the network, it also forced you to have to get all fields for the entry before you could perform the PUT operation.  The best way to do that is to first do a GET on the entry and store it in a generic !XmlEntry, make the changes to the !XmlEntry, and then PUT using the !XmlEntry.  It is still possible to use PUT with the library, but using PATCH is a lot easier.

Finally, let's clean up and delete the album:

{{{
  private static void deleteAlbum(GoogleTransport transport, AlbumEntry album) throws IOException {
    HttpRequest request = transport.buildDeleteRequest(album.getEditLink());
    request.setIfMatchHeader(album.etag);
    request.execute().ignore();
  }
}}}

Now, how do we handle a normal error response from the server?  The execute() method will throw an !HttpResponseException (which extends IOException) and has an !HttpResponse response field.  If the error response is a structured XML error response, you can use the same user-defined data model technique for parsing the error response:

{{{
import com.google.api.client.Entity;
import com.google.api.client.http.HttpResponseException;

    try {
...
    } catch (HttpResponseException e) {
      if (e.response.getParser() != null) {
        System.err.println(e.response.parseAs(Entity.class));
      } else {
        System.err.println(e.response.parseAsString());
      }
      throw e;
    }
}}}

Note that here we were lazy and used Entity which is a generic entity that processes all fields.  Your application may want to do something more specific.

NOTE: As you might guess, the library uses reflection to populate the user-defined data model. It's not quite as fast as writing the wire format parsing code yourself can potentially be, but it's a lot easier.

NOTE: If you prefer to write your own XML parsing code instead, that's supported as well. Just call request.execute() and parse the returned byte stream.