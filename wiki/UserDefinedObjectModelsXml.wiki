#summary Version 2 Feature: User-Defined Object Models in XML.

= [Version2 Version 2] Feature: User-Defined Object Models in XML =

Reference: [http://code.google.com/apis/picasaweb/docs/2.0/developers_guide_protocol.html Picasa Web Albums Atom XML Developer's Guide]

In this library, user-defined object models in XML are similar to [UserDefinedObjectModels user-defined object models in JSON-C].  However, it's not quite as elegant as JSON-C because we need to deal with XML namespaces.  Also, the structure of the data is more cumbersome to use.

The primary advantage of XML for Google API's is simply that it has been around much longer, and therefore all Google Data API's support it, but currently only !YouTube supports JSON-C.  Also, JSON-C is currently read-only.

Let's take a look at a typical Atom XML album feed from the Picasa Web Albums Data API (showing only the data our sample application is interested in):

{{{
<?xml version='1.0' encoding='utf-8'?>
<feed xmlns='http://www.w3.org/2005/Atom'
    xmlns:openSearch='http://a9.com/-/spec/opensearch/1.1/'
    xmlns:gphoto='http://schemas.google.com/photos/2007'>
  <link rel='http://schemas.google.com/g/2005#post'
    type='application/atom+xml'
    href='http://picasaweb.google.com/data/feed/api/user/liz' />
  <author>
    <name>Liz</name>
  </author>
  <openSearch:totalResults>1</openSearch:totalResults>
  <entry gd:etag='"RXY8fjVSLyp7ImA9WxVVGE8KQAE."'>
    <category scheme='http://schemas.google.com/g/2005#kind'
      term='http://schemas.google.com/photos/2007#album' />
    <title>lolcats</title>
    <summary>Hilarious Felines</summary>
    <gphoto:access>public</gphoto:access>
  </entry>
</feed>
}}}

How would you represent that in Java?  Here's one way to represent it for our sample application:

{{{
  public static class Link {

    @Name("@href")
    public String href;

    @Name("@rel")
    public String rel;
  }

  public static String getLink(List<Link> links, String rel) {
    for (Link link : links) {
      if (rel.equals(link.rel)) {
        return link.href;
      }
    }
    return null;
  }

  public static class Category {

    @Name("@scheme")
    public String scheme;

    @Name("@term")
    public String term;
  }

  public static Category newKind(String kind) {
    Category category = new Category();
    category.scheme = "http://schemas.google.com/g/2005#kind";
    category.term = "http://schemas.google.com/photos/2007#" + kind;
    return category;
  }

  public static class AlbumEntry {

    public String summary;

    public String title;

    @Name("gphoto:access")
    public String access;

    public Category category = newKind("album");
  }

  public static class Author {
    public String name;
  }

  public static class AlbumFeed {

    public Author author;

    @Name("openSearch:totalResults")
    public int totalResults;

    @Name("entry")
    public List<AlbumEntry> entries;

    @Name("link")
    public List<Link> links;

    String getPostLink() {
      return getLink(links, "http://schemas.google.com/g/2005#post");
    }
  }
}}}


Similarly, we can build URI using our own defined object model:

{{{
import com.google.api.data.client.http.HttpRequest;
import com.google.api.data.client.http.HttpTransport;
import com.google.api.data.picasa.v2.PicasaPath;
import com.google.api.data.client.v2.GDataUri;
import java.io.IOException;

  public static class PicasaUri extends GDataUri {

    @Name("max-results")
    public Integer maxResults;

    public String kinds;

    public PicasaUri(String uri) {
      super(uri);
    }
  }

  private static AlbumFeed showAlbums(HttpTransport transport) throws IOException {
    // build URI for the default user feed of albums
    PicasaPath path = PicasaPath.feed();
    path.user = "default";
    PicasaUri uri = new PicasaUri(path.build());
    uri.kinds = "album";
    String albumsUri = uri.build();
}}}

Now we execute the request and parse the result:

{{{
    HttpRequest request = transport.buildGetRequest(albumsUri);
    AlbumFeed feed = request.execute(AlbumFeed.class);
    System.out.println("User: " + feed.author.name);
    System.out.println("Total number of albums: " + feed.totalResults);
    for (AlbumEntry album : feed.entries) {
      showAlbum(transport, album);
    }
  }
}}}

Everything else we don't need just gets dropped, so it potentially uses much less memory than the version 1 client data classes.

Now, let's POST a new album to the album feed:

{{{
import com.google.api.data.picasa.v2.atom.PicasaAtom;

  private static AlbumEntry postAlbum(HttpTransport transport, AlbumFeed feed) throws IOException {
    AlbumEntry newAlbum = new AlbumEntry();
    newAlbum.access = "private";
    newAlbum.title = "A new album";
    newAlbum.summary = "My favorite photos";
    HttpRequest request = transport.buildPostRequest(feed.getPostLink());
    AtomSerializer.setContent(request, PicasaAtom.NAMESPACE_DICTIONARY, newAlbum);
    AlbumEntry postedAlbum = request.execute(AlbumEntry.class);
    showAlbum(transport, postedAlbum);
    return postedAlbum;
  }
}}}

NOTE: As you might guess, the library uses reflection to populate the user-defined object model. It's not quite as fast as writing the wire format parsing code yourself can potentially be, but it's a lot easier.

NOTE: If you prefer to write your own XML parsing code instead, that's supported as well. Just call request.execute() and parse the returned byte stream.