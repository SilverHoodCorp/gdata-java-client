#summary Migrating to Google API Client for Java

This guide is written for existing users of the Google Data Java Client Library, or "gdata-java-client", who are migrating to the new  [http://code.google.com/p/google-api-java-client/ Google API Client Library for Java], or "google-api-java-client".

=== Benefits of the New Library ===

As we have [http://www.youtube.com/watch?v=nyu5ZxGUfgs dramatically improved our internal API infrastructure], the gdata-java-client library has not kept up.  All new Google API's based on this new API infrastructure such as the Google Buzz API are not supported at all in the gdata-java-client library.  Moreover, although all new Google API's support the more efficient and natural JSON wire format, gdata-java-client only supports Atom XML.  New Google API technologies like partial response/update that improve efficiency by an order of magnitude are too difficult to use in the gdata-java-client library.

The gdata-java-client library also hasn't kept up with other technologies.  Most noticeably, it doesn't support Google's own Android mobile operating system.  Maven users have been complaining for years about the lack of support to upload the library to the central Maven repository.

We have been developing the gdata-java-client library over 5 years.   Our closed-source release process has grown into a complex, cumbersome, and error prone process.  Rather than developing new features for the client library, we spent most of our engineering resources on carefully fine-tuning data model classes for each Google API supported.  As developers reported problems with our data models, we were not able to or were very slow to respond.  Developers had no flexibility in customizing the data models for their needs.  Another point of internal frustration was the use of Subversion as the source control system which lacks the power and flexibility of a distributed source control system.

In order to solve these problems we had to start from scratch a year ago with the google-api-java-client (previously known as "version 2 of gdata-java-client").  Ideally a powerful API Java client library would work with all HTTP-based API's, and support all Java environments.  Thus, it was critical to design a fully pluggable architecture that hands the maximum power and flexibility to the developer using the library.  Simplicity is also a critical feature, and as you will see in this guide, working with Google API's is just as simple in google-api-java-client as it was with gdata-java-client.  The difference is that the same simplicity applies to working with all wire formats, especially with JSON.  Furthermore, the developer can customize their JSON or XML data model for their application's needs, rather than having to rely on Google to provide it to them. Partial response/update is also supported with ease because it relies on the developer's data model to automatically compute the most efficient representation of their data.

Another reason we started with a new project because we wanted to get the internals of the project right.  We wanted to use Maven as the build and release system, and we wanted it to be completely open source from the start.  We wanted to use Mercurial as the source control system for it's more flexible distributed features, and to enable external contributions without requiring a Committer role.

Long term, all new features will only be developed in google-api-java-client, and not in gdata-java-client.  For example, we are already have a prototype of OAuth 2 running in google-api-java-client.

Since we are not deprecating gdata-java-client at this point, we will continue to fix any critical bugs.  If you are unable to migrate to google-api-java-client yet, rest assured you are still using a stable and supported client library.

=== Overall Migration Process ===

Start by learning about google-api-java-client on the [http://code.google.com/p/google-api-java-client/ project's front page].  Keep up to date with the latest discussions and announcements, or ask questions or provide feedback on the [http://groups.google.com/group/google-api-java-client Help Forum].  [http://code.google.com/p/google-api-java-client/source/browse?repo=samples Samples] are usually the best way to learn how to write code using this library, and over time we hope to have a sample for every Google Data API.
 
Since gdata-java-client and google-api-java-client are independent projects, it is completely safe to include both in your Java classpath.  The easiest way to get started is to write new code using google-api-java-client, and migrate existing code from gdata-java-client to google-api-java-client over time as you gain confidence using google-api-java-client.

The architecture of a typical application based on google-api-java-client is based on design to a Model-View-Controller style:
   * Model: write a custom XML data model for the Google Data API based on the fields your application needs.  Take a look at the [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/xml/atom/package-summary.html JavaDoc].
   * Controller: write the request execution methods.  The [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/xml/atom/package-summary.html JavaDoc] above also explains how to do that.
   * View: write the user interface, including authentication and authorization.  The recommend approach is to use [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/auth/oauth/package-summary.html OAuth], or [http://developer.android.com/reference/android/accounts/AccountManager.html AccountManager] for Android.  [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/auth/clientlogin/package-summary.html ClientLogin] and [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/auth/authsub/package-summary.html AuthSub] are also supported.

=== Implementation Details ===

First, you need to invest in writing a custom data model that lets your application access the Google API fields it needs.  Please read the [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.9-alpha/com/google/api/client/googleapis/xml/atom/package-summary.html JavaDoc for the new XML data model] in google-api-java-client. Over time, we will work on samples to demonstrate how to do this for many more Google APIs. 

If there is already a sample for the API you are using, you have a great starting point.  You can copy the data model classes it uses directly into your application.  Of course, since it is just a sample, it shows only the data classes and fields that the sample needs.  Although you'll probably need to extend the sample code, you can do this easily by applying the same techniques it demonstrates. 

Even if there is not yet a sample for the particular API you are using, you can still use google-api-java-client.  There are three key differences between using the new library and the old one: 

First, there is a much different calling style with google-api-java-client.  Instead of calling the !YouTubeService, you start with the generic !HttpTransport class.  In fact, you do this regardless of which API you are using.  So, in the case of !YouTube, you previously you might have written code like this:

{{{
  YouTubeService service = new YouTubeService("google-youtubesample-1.0");
}}}

With google-api-client, you now have a few more lines of code:

{{{
    HttpTransport transport = GoogleTransport.create();
    GoogleHeaders headers = (GoogleHeaders) transport.defaultHeaders;
    headers.setApplicationName("google-youtubesample-1.0");
    headers.gdataVersion = "2";
}}}

Second, authentication is different in gdata-java-client and google-api-java-client.  For example, if you are using !ClientLogin, you used to do something like:

{{{
  service.setUserCredentials(username, password);
}}}

But with the new library, it's more lines of code:

{{{
    ClientLogin authenticator = new ClientLogin();
    authenticator.authTokenType = "youtube";
    authenticator.username = username;
    authenticator.password = password;
    authenticator.authenticate().setAuthorizationHeader(transport);
}}}

By the way, if you are migrating to the new client library and are still using !ClientLogin, your application still needs to ask your end users for their username and password.  For a much better security technique, please seriously consider also migrating to [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.9-alpha/com/google/api/client/auth/oauth/package-summary.html OAuth].

Third, you write your own API-specific class that extends !GoogleUrl and adds the query parameters you want to use; there is no !YouTubeQuery to help you construct a URL with google-api-java-client.  Here is an example for !YouTube:

{{{
public static class YouTubeUrl extends GoogleUrl {
  @Key public String orderby;
  @Key public String q;
  @Key public String safeSearch;
  public YouTubeUrl(String encodedUrl) {
    super(encodedUrl);
  }
}
}}}

Let's put it all together. Previously, the code you wrote when you used gdata-java-client looked something like this:
http://code.google.com/apis/gdata/docs/client-libraries.html
{{{
public static void printPuppyVideos(YouTubeService service) {
  YouTubeQuery query = new YouTubeQuery(new URL("http://gdata.youtube.com/feeds/api/videos"));
  // order results by the number of views (most viewed first)
  query.setOrderBy(YouTubeQuery.OrderBy.VIEW_COUNT);

  // search for puppies and include restricted content in the search results
  query.setFullTextQuery("puppy");
  query.setSafeSearch(YouTubeQuery.SafeSearch.NONE);

  VideoFeed videoFeed = service.query(query, VideoFeed.class);
  for (VideoEntry videoEntry : videoFeed.getEntries()) {
    System.out.println("Title: " + videoEntry.getTitle().getPlainText());
  }
}
}}}

Now, with the google-api-java-client, the code you write looks more like this:

{{{
public static void printPuppyVideos(HttpTransport transport) {
  YouTubeUrl url = new YouTubeUrl("http://gdata.youtube.com/feeds/api/videos");
  // order results by the number of views (most viewed first)
  url.orderBy = "viewCount";

  // search for puppies and include restricted content in the search results
  url.q = "puppy";
  url.safeSearch = "none";

  HttpRequest request = transport.buildGetRequest();
  request.url = url;
  VideoFeed videoFeed = request.execute().parseAs(VideoFeed.class);
  for (VideoEntry videoEntry : videoFeed.videos) {
    System.out.println("Title: " + videoEntry.title);
  }
}
}}}

There are other differences as well.  For example, you have to specify XML namespaces manually, and the way you insert new items into a feed is different. We'll be adding more information about these kinds of issues soon.

Feel free to ask us questions to help you in your migration process.  If you are interested in seeing a sample for a particular Google API or feature, please let us know so we can prioritize samples that most developers need.  In addition, we will be updating this document over time with more examples to help you.  Good luck!