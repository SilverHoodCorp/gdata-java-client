#summary Migrating to Google API Client for Java

This guide is written for existing users of the Google Data Java Client Library, or "gdata-java-client," who are migrating to the new  [http://code.google.com/p/google-api-java-client/ Google API Client Library for Java], or "google-api-java-client."

=== Benefits of the New Library ===

The google-api-java-client is Google's new Java client library for Google APIs. Long term, we will be developing all new features in google-api-java-client and not in gdata-java-client.  Some benefits of the new library include its support for:
  * New APIs based on Google's [http://www.youtube.com/watch?v=nyu5ZxGUfgs dramatically improved API infrastructure], such as the Google Buzz API. 
  * Google's Android mobile operating system.
  * The more efficient and natural JSON wire format (gdata-java-client only supports Atom XML).
  * More efficient partial response and update (less complicated to do than in gdata-java-client).
  * The Maven distribution system.
  * New, upcoming features like OAuth 2 (library already includes a prototype) and the Discovery API.

We started from scratch about a year ago so we could take what we've learned from gdata-java-client and make major improvements. We came up with a design that supports a much more streamlined release process. The new library works with all HTTP-based APIs, including existing GData APIs, and supports all Java 5 (or higher) environments. It is a fully pluggable architecture that hands the maximum power and flexibility to you, the developer. 

Previously known as "version 2 of gdata-java-client," we  decided to start a new project so we could get the project internals right. We wanted to use Maven, which has been much-requested, as the distribution system. We wanted it to be completely open source from the start. To better support open-source, we wanted to replace Subversion with the Mercurial source control system, which has more flexible distributed features and enables external contributions without requiring a Committer role. 

As you will see in this guide, working with Google APIs is just as simple with google-api-java-client as it was with gdata-java-client. Yet the simplicity of working with the new library extends even further. It provides equal support for the JSON wire format and even supports plugging in alternative formats. It lets you customize your JSON or XML data model for your application's needs, rather than having to rely on Google to provide it to you. It offers great support for partial response/update (features that can improve efficiency by an order of magnitude) because it uses your data model to automatically compute the most efficient representation of your data.

=== Why the Different Approach? ===

We have been developing the gdata-java-client library over 5 years. Over time, our closed-source release process for it has grown complex and cumbersome. We had to spend most of our engineering resources on carefully fine-tuning data model classes for each Google API supported, when we would rather have spent it developing new features for the client library. When developers reported problems with our data models, we were often unable to respond quickly. Developers had no flexibility in customizing the data models for their needs. 

=== What if I'm Not Ready to Migrate? ===

We are not deprecating gdata-java-client at this point, and we will continue to fix any critical bugs.  If you are unable to migrate to google-api-java-client yet, rest assured you are still using a stable and supported client library.

=== Migration Process Overview ===

Start by getting an overview about google-api-java-client on the [http://code.google.com/p/google-api-java-client/ project's front page]. [http://code.google.com/p/google-api-java-client/source/browse?repo=samples Samples] are usually the best way to learn how to write code using this library, and over time we hope to have a sample for every Google Data API. Keep up to date with the latest discussions and announcements, or ask questions or provide feedback on the [http://groups.google.com/group/google-api-java-client Help Forum].

Since gdata-java-client and google-api-java-client are independent projects, it is completely safe to include both in your Java classpath.  The easiest way to get started is to write new code using google-api-java-client, and migrate existing code from gdata-java-client to google-api-java-client over time as you gain confidence using google-api-java-client.

The architecture of a typical application based on google-api-java-client is based on design to a Model-View-Controller style:
   * Model: Write a custom XML data model for the Google Data API based on the fields your application needs.  See the [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/xml/atom/package-summary.html JavaDoc] for more information on writing a custom data model.
   * Controller: Write the request execution methods.  The [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/xml/atom/package-summary.html JavaDoc] above also explains how to do that.
   * View: Write the user interface, including authentication and authorization.  The recommended approach is to use [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/auth/oauth/package-summary.html OAuth], or [http://developer.android.com/reference/android/accounts/AccountManager.html AccountManager] for Android.  [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/auth/clientlogin/package-summary.html ClientLogin] and [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.10-alpha/com/google/api/client/googleapis/auth/authsub/package-summary.html AuthSub] are also supported.

=== Migrating Your Code ===

First, you need to invest in writing a custom data model that lets your application access the Google API fields it needs.  See the [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.9-alpha/com/google/api/client/googleapis/xml/atom/package-summary.html JavaDoc for the new XML data model] in google-api-java-client. 

If there is already a sample for the API you are using, you have a great starting point.  You can copy the data model classes it uses directly into your application.  Of course, since it is just a sample, it shows only the data classes and fields that the sample needs, so you'll probably need to add more data classes and fields.  It's easy to do this, or even to use google-api-java-client with an API that doesn't yet have a sample, by applying the same techniques demonstrated in the existing samples.

There are three other key differences between how you set up the API using the new library and the old one:

First, there is a much different calling style with google-api-java-client.  Instead of calling a service by name, you start with the generic !HttpTransport class and set the application name in its headers.   So, in the case of !YouTube, you previously you might have written code like this:

{{{
  YouTubeService service = new YouTubeService("google-youtubesample-1.0");
}}}

With google-api-client, it's a few more lines of code:

{{{
    HttpTransport transport = GoogleTransport.create();
    GoogleHeaders headers = (GoogleHeaders) transport.defaultHeaders;
    headers.setApplicationName("google-youtubesample-1.0");
    headers.gdataVersion = "2";
}}}

Second, authentication is different in gdata-java-client and google-api-java-client.  For example, if you are using !ClientLogin, you used to do something like:

{{{
  service.setUserCredentials(username, password);
}}}

But with the new library, you write code like this:

{{{
    ClientLogin authenticator = new ClientLogin();
    authenticator.authTokenType = "youtube";
    authenticator.username = username;
    authenticator.password = password;
    authenticator.authenticate().setAuthorizationHeader(transport);
}}}

By the way, if you are migrating to the new client library and are still using !ClientLogin, your application still needs to ask your end users for their username and password.  For a much better security technique, please seriously consider also migrating to [http://javadoc.google-api-java-client.googlecode.com/hg/1.0.9-alpha/com/google/api/client/auth/oauth/package-summary.html OAuth].

Third, you write your own API-specific class that extends !GoogleUrl and adds the query parameters you want to use; there is no !YouTubeQuery to help you construct a URL with google-api-java-client.  Here is an example for !YouTube:

{{{
public static class YouTubeUrl extends GoogleUrl {
  @Key public String orderby;
  @Key public String q;
  @Key public String safeSearch;
  public YouTubeUrl(String encodedUrl) {
    super(encodedUrl);
  }
}
}}}

Once you've set up the basics of the API, you're ready to use it in your application.  Previously, the code you wrote when you used gdata-java-client looked something like this:
http://code.google.com/apis/gdata/docs/client-libraries.html
{{{
public static void printPuppyVideos(YouTubeService service) {
  YouTubeQuery query = new YouTubeQuery(new URL("http://gdata.youtube.com/feeds/api/videos"));
  // order results by the number of views (most viewed first)
  query.setOrderBy(YouTubeQuery.OrderBy.VIEW_COUNT);

  // search for puppies and include restricted content in the search results
  query.setFullTextQuery("puppy");
  query.setSafeSearch(YouTubeQuery.SafeSearch.NONE);

  VideoFeed videoFeed = service.query(query, VideoFeed.class);
  for (VideoEntry videoEntry : videoFeed.getEntries()) {
    System.out.println("Title: " + videoEntry.getTitle().getPlainText());
  }
}
}}}

Now, with the google-api-java-client, the code you write looks more like this:

{{{
public static void printPuppyVideos(HttpTransport transport) {
  YouTubeUrl url = new YouTubeUrl("http://gdata.youtube.com/feeds/api/videos");
  // order results by the number of views (most viewed first)
  url.orderBy = "viewCount";

  // search for puppies and include restricted content in the search results
  url.q = "puppy";
  url.safeSearch = "none";

  HttpRequest request = transport.buildGetRequest();
  request.url = url;
  VideoFeed videoFeed = request.execute().parseAs(VideoFeed.class);
  for (VideoEntry videoEntry : videoFeed.videos) {
    System.out.println("Title: " + videoEntry.title);
  }
}
}}}

There are other differences as well.  For example, how you handle XML namespaces and the way you insert new items into a feed is different. We'll be adding more information about these kinds of issues soon.

Feel free to ask us questions to help you in your migration process.  If you are interested in seeing a sample for a particular Google API or feature, please let us know so we can prioritize samples that most developers need.  In addition, we will be updating this document over time with more examples to help you.  Good luck!